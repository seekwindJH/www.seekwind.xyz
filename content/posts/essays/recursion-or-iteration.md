---
title: "递归 or 迭代？思考"
date: 2022-01-06T20:45:07+08:00
draft: false
---

<!--more-->

能用递归解决的问题，往往也能用迭代解决，反之亦然。而在数据结构与算法的学习过程中，我们不难发现，某些算法（例如二叉树的深度优先遍历），迭代实现比递归实现要困难的多。既然递归比迭代写着简单，那我们为何要使用迭代呢？

在网络上搜索后，能发现大量的文章，它们的观点大致如下：

> 观点1. 迭代有时能够用常数级别的额外空间，而递归产生的函数调用栈则会产生大量的额外开销。这种现象最典型的就是*斐波那契数列*的求解。在递归中，我们不得不使用递归调用栈，而且，为了保存计算结果，我们甚至不惜开辟一个数组去存放自底向上计算的结果。在迭代中，我们只需要简简单单的2个int，就能很好的存储结果。

它说的一点没错，但是我不认可这种观点。关于是否使用额外空间，这理应是算法实现上的问题。像斐波那契数列此类问题，如果使用迭代只需要常数级别的额外空间，那么选择递归**理应属于算法选择上的失策，而并非归属于递归的缺点**。请仔细揣摩笔者这句话。递归不应该背锅，而是程序员或者算法工程师的失责。

在使用递归合理的算法中，函数调用栈能够存放必须使用的中间变量。这些中间变量，即使是使用迭代也不能避免（不能用常数级别的空间化解）。只有在这种情况下，递归与迭代才有了可比性。而我们的问题，应该从此处开始探讨。

> 观点2. 当递归层次过深时，递归调用栈量大易导致调用栈溢出，最终造成`Stack Overflow Error`。

这种观点就更加不对了。如果递归层次过深，这意味着产生的额外空间消耗十分多。那么当消耗额外空间过多时，即使是使用迭代，依旧会产生`Heap Overflow Error`。只不过，在使用迭代时，在某些情况下，我们可以在开辟额外的存储空间（数组）的那一刻，就知道内存是否够用，以及时止损。

这个问题本身没有标准答案，但笔者认为，可能是垃圾回收算法产生的一些问题。

在现代高级编程语言中，例如Java、Golang、Python，自动垃圾回收机制是十分重要的。而对于不同的内存区域，垃圾回收策略是不一致的。例如，在高频发生内存抖动的Heap区域，必然使用更加激进的垃圾回收策略。而在调用栈这种不常需要垃圾回收的区域，保存着GC Root。那么当调用栈中充斥大量的函数调用栈时，GC Root的量将会十分巨大，这给垃圾回收带来了困难。
